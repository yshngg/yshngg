# 虚拟内存基础

## 是什么 & 为什么需要？

你有没有想过：既然有磁盘存储，为什么计算机还需要主内存（RAM）？答案在于访问速度。
虽然磁盘存储是持久的，但远比主存慢。RAM 以牺牲持久性换取速度——断电后数据会丢失，但访问速度快得多。因此，CPU 只能直接从主内存访问数据，而不能直接从磁盘访问。

CPU 自带的寄存器比主存更快。那为什么还需要主存？因为寄存器数量和容量有限。想象一个函数需要处理一千个变量——不可能把它们全部放进寄存器。再比如要存放大型数据结构（数组、结构体等），寄存器根本不够。这时主存就派上用场：它提供了处理更大、更复杂数据所需的空间。

主存是一个很大的字节数组，大小从几十万字节到数十亿字节不等。每个字节都有自己的地址。要执行一个程序，必须将其映射到绝对地址并加载到内存中。一旦加载，进程（程序的一个活动执行实例）就通过这些绝对地址访问指令、从内存读取并向内存写入数据。同理，CPU 若要处理磁盘上的数据，必须先通过 CPU 发起的 I/O 调用将那些数据传到主存中。

## 简单的分配策略

通常，计算机上会同时运行多个进程，每个进程在主存中有自己的内存空间。操作系统负责为每个进程分配内存，确保它们互不干扰。最简单的内存分配方法之一是为每个进程分配一个可变大小的连续内存块，每个块恰好包含一个进程。

| <img src="simple_allocation.png" width=500> |
| :-----------------------------------------: |
|       连续内存块分配策略 <sup>1</sup>       |

当进程被创建时，操作系统会根据每个进程的内存需求和可用内存空间分配足够的分区。分配后，进程被加载到内存并开始执行。进程结束后，操作系统会回收该内存块，使其可供其他进程使用。如果没有足够的空间容纳新进程，操作系统可能需要将某些进程换出到磁盘以释放内存。另一种做法是把这些进程放入等待队列。当内存随后被释放时，操作系统会检查等待队列，看是否能满足等待中进程的内存需求。

在分配过程中，操作系统必须寻找足够大的连续内存块以放下进程。有很多算法可以完成这项工作，例如首次适配（first-fit）、最佳适配（best-fit）和最差适配（worst-fit）。首次适配从头开始搜索第一个足够大的空闲块，找到后就停止；最佳适配遍历整个内存空间，找到最小的足够大块；最差适配遍历整个内存空间，找到最大的足够大块。总体而言，first-fit 和 best-fit 在时间和存储利用上通常优于 worst-fit。first-fit 通常更快，尽管在存储效率方面两者相差不大。

## 外部碎片（External Fragmentation）

不幸的是，这种简单的连续分配策略会产生外部碎片。外部碎片发生在总的空闲内存足以满足请求，但可用空闲空间不是连续的。这类碎片会成为严重问题。最糟糕的情况下，可能在每两个已分配进程之间都有一小块空闲内存。如果把这些分散的碎片合并成一个大块，系统或许可以运行更多的进程。

| <img src="memory_fragmentation.png" width=550> |
| :--------------------------------------------: |
|         连续内存块分配策略下的外部碎片         |

实际上，在分配时通常无法预知进程将来需要的最大内存。这是因为进程可能会根据用户输入或其他因素进行动态内存分配。如果已分配的内存不够，操作系统可能需要暂停该进程、搜索足够大的内存块并将进程迁移到更大的内存块。这种做法会导致严重的性能问题，因此并不现实。

## 内存分页（Memory Paging）

在实践中，操作系统使用一种更复杂的内存分配策略——**分页（paging）**，以避免外部碎片。分页将主存划分为固定大小的块，称为**帧（frames）**。操作系统不再为每个进程分配一个连续的块，而是分配多个可以散布在主存各处的帧。

谈到分页时，需要区分**物理内存**和**虚拟内存**（或 **逻辑内存**）。物理内存指安装在计算机上的主存，而虚拟内存是操作系统用来管理进程内存的抽象。进程只能访问虚拟内存，操作系统负责将虚拟内存映射到物理内存。尽管进程的物理内存可能是不连续的，但从每个进程的角度来看，它拥有隔离的（**独立的**）虚拟内存空间，看起来像是一个连续的块。

> 🧑‍💻 要演示虚拟内存的概念，你可以运行这个 Go 程序，记录地址用于之后比较，打开其他程序，然后再运行该程序。
>
> ```go
> package main
>
> func main() {
>   x := 0
>   println(&x)
> }
> ```
>
> 你会发现即使有新的进程进入，变量的地址保持不变。这是因为该变量在进程的虚拟内存空间中被分配到了相同的地址。

虚拟内存被划分为固定大小的块，称为**页（pages）**，其大小与物理内存中的帧相同。通过将虚拟内存与物理内存分离，并结合诸如**按需分页（demand paging）**等技术，一个进程在 64 位架构上可以访问高达 18.4 百万 TB 的地址空间，而在 32 位架构上可达 4 GB，即使实际物理内存可能小得多（例如 512 MB）。

每个页有一个页号 _p_，每个帧有一个帧号 _f_。每个地址还有一个偏移量 _d_，用于标识页或帧内的具体位置。页号 _p_ 和帧号 _f_ 位于地址的高位，而偏移量 _d_ 位于低位。虚拟页到物理帧的映射保存在进程特有的数据结构中，称为**页表（page table）**。在页表中，每一项按页号 _p_ 索引，其对应的值是帧号 _f_。

| <img src="page_table.png" width=550> |
| :----------------------------------: |
|        分页硬件 <sup>2</sup>         |

为了把一个虚拟地址转换为物理地址，执行如下步骤：

1. 从虚拟地址中提取页号 _p_。
2. 访问页表以检索对应的帧号 _f_。
3. 在虚拟地址中用帧号 _f_ 替换页号 _p_。

| <img src="paging_model.png" width=400> |
| :------------------------------------: |
|         分页模型 <sup>3</sup>          |

注意：实际上页表结构并不总是那么简单，为了高效管理内存可以采用多种形式。一种常见的方法（Linux 使用的）是**多级页表**，每一层包含指向下一层页表的条目，最终指向物理帧。另一种方法是**哈希页表（hashed page table）**，用哈希函数把虚拟页号映射到哈希表条目，这些条目指向物理帧。第三种是**反向页表（inverted page table）**，其中每个条目代表物理内存中的一个帧，并存储当前驻留在该帧中的页的虚拟地址以及所属进程的信息。

| <img src="hierarchical_page_table.png" width=400> | <img src="hashed_page_table.png" width=400> | <img src="inverted_page_table.png" width=400> |
| :-----------------------------------------------: | :-----------------------------------------: | :-------------------------------------------: |
|           分层（多级）页表 <sup>4</sup>           |            哈希页表 <sup>5</sup>            |             反向页表 <sup>6</sup>             |

虚拟内存允许多个进程通过页共享（page sharing）来共享文件和内存。例如，Chrome 的每个标签页是一个独立的进程，但它们使用相同的共享库（如 libc、libssl）。操作系统不会为每个标签页加载独立的副本，而是将相同的物理页映射到多个进程，从而大幅减少内存使用。

## 按需分页（Demand Paging）

如前所述，要执行一个程序必须先把它加载到主存中。但对于大型程序，不必一次性把整个程序装入内存，只需装入当前需要的部分。想想开放世界游戏：整个地图可能非常大，但玩家在任一时刻仅与一个小区域（例如周围 1 平方公里）交互。这就是按需分页的作用——只在需要时加载程序的相应页。

| <img src="demand_paging.png" width=400> |
| :-------------------------------------: |
|          按需分页 <sup>7</sup>          |

当进程执行时，其部分页被加载到内存，而其他页仍保留在磁盘（即备份存储）。为此，页表中增加了一列，称为**有效—无效位（valid-invalid bit）**，用于指示每页的状态。如果该位被置为**有效（v）**，表示该页既是合法的（属于进程的逻辑地址空间）且当前已装入内存；如果被置为**无效（i）**，该页要么超出了进程的逻辑地址空间（非法），要么是合法页但当前驻留于磁盘上。

当进程尝试访问一个其有效—无效位为无效（i）的页时，就会发生**缺页（page fault）**，触发一个陷阱（trap）进入操作系统。操作系统随后按以下步骤处理缺页：

1. 检查进程的内部表以确定该内存引用是否有效。
2. 如果地址无效（即不属于进程的逻辑地址空间），终止该进程。
3. 如果地址有效但该页当前不在内存中，则把该页换入（page in）。
4. 操作系统在物理内存中找到一个空闲帧。
5. 指示磁盘读取所需页到新分配的帧中。
6. 完成后，更新进程的内部表和页表以反映该页已存在于内存中。
7. 进程从导致缺页的指令处恢复执行。

在 Linux 中，有两个重要的内存度量：**Resident Set Size (RSS)** 和 **Virtual Size (VSZ)**。RSS 表示进程当前使用的物理内存量，包括共享内存但不包括已换出的页面。VSZ 则表示分配给进程的总虚拟内存大小，包括共享库和整个被保留的地址空间，无论这些页面当前是否在物理内存中或是否已被换出。VSZ 还包括进程已分配但尚未使用的内存（比如通过 `mmap` 或 `malloc` 保留的但未访问的内存），这些内容不包含在 RSS 中。

## 虚拟内存布局

尽管虚拟内存的抽象让用户空间程序员不用直接管理物理内存，但在内存分配时仍会遇到挑战。开发者需要考虑在哪里分配内存、某个地址是否合法、是否与代码段等保留区域冲突。为了解决这些问题，操作系统引入了**虚拟内存布局（virtual memory layout）**的概念。从进程的角度看，虚拟地址布局如下所示（地址向上增长）。

| <img src="virtual_memory_layout.png" width=400> |
| :---------------------------------------------: |
|  x86-64 Linux 进程的虚拟内存布局 <sup>8</sup>   |

虚拟内存布局分为若干段：

1. **内核虚拟内存空间（Kernel virtual memory space）**：保留给内核，用户态不可访问。
2. **（用户）栈（Stack）**：保存主线程的栈帧，向下增长。
3. **内存映射区域（Memory mapped regions）**：通过 `mmap` 为共享内存、文件或匿名映射分配的内存。
4. **堆（Heap）**：进程用于动态内存分配的区域，向上增长。
5. **已初始化数据段（`.data`）**：包含程序已初始化的全局和静态变量。
6. **未初始化数据段（`.bss`）**：包含程序未初始化的全局和静态变量。
7. **只读代码段（Read-only code segment）**：包含可执行代码，通常为只读。

注意：这些段本质上只是进程虚拟地址空间中的若干页。

## 栈分配（Stack Allocation）

每个进程都有一个栈（stack），用于在某个时间点跟踪局部变量和函数调用。栈是一个向下增长的数据结构：当函数被调用并分配局部变量时，栈向下增长；当函数返回时，栈向上收缩。当函数被调用时，会在栈上创建一个新的**栈帧（stack frame）**，包含函数的局部变量、参数和返回地址。函数返回时，其栈帧被弹出，从而释放该帧内的所有变量。

| <video width=500 autoplay controls id="stack_frame.mp4"><source src="stack_frame.mp4"/></video> |
| :---------------------------------------------------------------------------------------------: |
|                       可视化：程序执行时进程栈如何增长与收缩 <sup>9</sup>                       |

每个线程都有自己的栈。由于一个进程可以有多个线程，进程内可能有多个栈。提到“进程栈”时，通常指主线程的栈。创建线程时，会为其分配一个与主线程栈独立的栈。由于每个线程有独立的栈，栈分配不需要同步。如果使用 `pthread_create` 创建新线程，内核默认会自动选择一个合适的内存区域作为该线程的栈。也可以使用 `pthread_attr_setstack` 手动指定栈的起始地址。对于使用 `clone` 创建的线程，该行为也适用。

线程栈的大小在创建线程时固定，不能动态调整。栈的默认大小由资源限制 `RLIMIT_STACK` 决定。`RLIMIT_STACK` 的默认值在大多数架构上通常为 2 MB，在 POWER 和 Sparc-64 上为 4 MB。尽管 `RLIMIT_STACK` 是全局设置，但如果想为某个线程设置特定栈大小，可以使用 `pthread_attr_setstacksize`，以便在该线程需要分配较大自动变量或进行深度递归调用时有更大的栈空间。

为了跟踪栈顶，CPU 使用一个特殊寄存器称为**栈指针（stack pointer）**。不同架构上名称不同：在 x86-64 上通常为 `RSP`，在 x86 上为 `ESP`，在 ARM 上为 `SP`。在线程开始执行前，栈指针初始化为指向栈顶。由于线程栈在创建时已预先分配，把变量分配到栈上仅仅是移动栈指针向下，这是一种非常快的操作。从栈中加载变量也很快，只需读取栈指针指向地址处的值。

还有另一个特殊寄存器称为**基指针（base pointer，或帧指针 frame pointer）**，它指向当前栈帧的起始位置。基指针用于作为访问局部变量和函数参数的稳定参考点。栈的释放通过将栈指针恢复到基指针来完成，这也是一个快速操作。

由于栈分配在编译时确定，编译器负责计算所有变量的大小并生成相应的汇编代码来在栈上分配它们。编译器还会在函数返回时发出指令以释放栈帧。例如，通常使用 `MOVD` 将变量存入栈中，使用 `ADD` 增加栈指针以释放栈帧。

| <img src="general_stack_frame.png" width=300> |
| :-------------------------------------------: |
|         一般栈帧示意图 <sup>10</sup>          |

上图展示了在函数 `P` 调用函数 `Q` 的场景下的一般栈帧布局。当前执行过程的帧总是位于栈顶。基指针（`%rbp`）标记当前栈帧的开始，而栈指针（`%rsp`）指向栈顶。在 `P` 执行期间，它可能通过调整栈指针来在栈上为局部变量分配空间。

当 `P` 调用 `Q` 时，会把返回地址压入栈中，返回地址告诉程序在 `Q` 返回后从哪里继续执行 `P`。这个返回地址被视作 `P` 的栈帧的一部分，因为它保存了与 `P` 相关的状态。此时，`P` 也可能保存寄存器值并为被调用程序准备参数。当控制权转移到 `Q` 时，基指针 `%rbp` 不再指向 `P` 的栈帧，而更新为指向 `Q` 的栈帧起始位置。`Q` 在返回时通过减小栈指针来释放自己的栈帧。

并非所有变量都应分配在栈上，原因包括：栈分配在编译时确定，如果变量的大小在编译时未知，就无法分配到栈上；另外，如果一个变量是函数 `F` 的局部变量，但在 `F` 返回后仍被其他函数引用，把它分配在栈上会导致访问无效地址。在这种情况下，需要把该变量分配到堆上。

## 堆分配（Heap Allocation）

在堆上分配变量意味着在堆段中找到一个空闲内存块，或者在没有可用块时调整堆的大小。堆当前的边界称为**程序断点（program break，简称 brk）**，如下图所示。

| <img src="virtual_memory_layout.png" width=400> |
| :---------------------------------------------: |
|         程序断点在虚拟内存布局中的位置          |

调整堆大小就是告诉内核更改它所认为的程序断点的位置。程序断点上移后，程序可以访问新分配区域中的任意地址，但此时并不会立即分配物理内存页。内核会在进程第一次访问这些页时自动分配新的物理页。一旦堆的虚拟内存扩展，程序可以选择任意内存块来存放变量的值。

Linux 提供 `brk` 系统调用来改变程序断点的位置，以及 `sbrk` 系统调用来增加程序断点的大小。虽然程序员在分配变量时通常关心其大小，但在 Linux 中很少直接使用 `brk` 和 `sbrk`，而通常使用 `malloc`。

`malloc` 首先扫描之前由 `free` 释放的空闲内存块列表，寻找一个大小大于或等于所需空间的块。具体扫描策略取决于实现，可能使用 first-fit 或 best-fit 等算法。如果块正好合适则直接返回；如果块较大，则将其拆分，返回所需大小的块并把剩余部分放回空闲链表。如果空闲链表中没有足够大的块，`malloc` 会调用 `sbrk` 来申请更多内存。为了减少对 `sbrk` 的调用次数，`malloc` 通常不会仅按需增加恰好所需的量，而是以较大的单位增加程序断点，把多余的内存放到空闲链表中备用。

下图示意 `malloc` 如何管理堆中的内存块，堆被当作一个一维的内存地址数组。每个内存块除了用于存放变量值的实际空间外，还会存储元数据（如块长度、指向空闲链表中前后块的指针等）。这些元数据使 `malloc` 和 `free` 能够正常工作。

| <img src="free_list_visualization.png" width=300> |
| :-----------------------------------------------: |
|           空闲链表可视化 <sup>11</sup>            |

由于堆在线程间是共享的，为避免多线程应用中内存管理数据结构被破坏，内部会使用互斥锁来保护这些数据结构。在多线程应用中，线程同时进行分配和释放时可能会产生互斥锁争用。因此，堆分配通常比栈分配效率低。

## 内存映射（Memory Mapping）

在虚拟内存布局图中，除了堆和栈之外，还有一段称为**内存映射区域（memory mapped regions）**。内存映射分为文件映射（file mapping）和匿名映射（anonymous mapping）两类。文件映射将文件的一个区域直接映射到调用进程的虚拟内存，从而可以通过对相应内存区域字节的操作来访问其内容。匿名映射没有对应的文件，映射的页面会初始化为 0。也可以把匿名映射理解为一个虚拟文件，其内容总是以零初始化。

| <img src="memory_layout_elf.png" width=400> |
| :-----------------------------------------: |
|      ELF 程序的内存布局 <sup>12</sup>       |

内存映射区域可以是**私有的（private，也称写时复制 copy-on-write）**或**共享的（shared）**。私有映射意味着该内存区域只对创建它的进程可见。当进程尝试修改某页内容时，内核首先为该进程创建该页的一个新副本，并调整该进程的页表。相反，如果映射是共享的，那么所有共享该映射的进程都能看到其它进程的修改。

按需分页同样适用于内存映射。当用户进程的地址空间扩展时，内核并不会立即为这些新的虚拟地址分配物理内存。相反，内核采用按需分页：只有当用户进程尝试写入新的虚拟内存地址时，才从物理内存中分配一页并映射到该地址。读访问会导致创建一个页表项，引用一个特殊的、填充为零的物理页面。<sup>[13](https://ryanstan.com/linux-demand-paging-anon-memory.html)</sup><sup>[14](https://www.kernel.org/doc/html/v5.16/admin-guide/mm/concepts.html#anonymous-memory)</sup>

由于匿名映射没有文件 backing 且总是以零初始化，它们非常适合实现自定义内存分配策略的程序（例如 Go），而不是依赖操作系统的默认分配器（如 `malloc`/`free`）。这允许更细粒度的内存管理控制，支持自定义分配器或为运行时（如 GC）量身定做的策略。

Linux 提供 `mmap` 系统调用在进程的虚拟地址空间中创建新的内存映射。值得一提的参数是 `addr`，它指定映射的首选起始地址。如果 `addr` 为 `NULL`，内核会自动选择一个合适地址；如果提供了非 `NULL` 值，内核会把它作为提示尝试将映射放在该地址附近，并向最近的页边界对齐。在任何情况下，内核都会确保所选地址不会与现有映射冲突。

## 参考文献

- Core Dumped. [_Why is the Stack So Fast?_](https://www.youtube.com/watch?v=N3o5yHYLviQ)
- Michael Kerrisk. [_The Linux Programming Interface_](https://man7.org/tlpi/).
- Abraham Silberschatz, Peter B. Galvin, Greg Gagne. <a href="https://www.amazon.com/Operating-System-Concepts-Abraham-Silberschatz/dp/1119800366/ref=zg-te-pba_d_sccl_3_1/138-7692107-2007040"><i>Operating System Concepts</i></a>.
