# 架构

为确保关注点清晰分离，我们将 containerd 的行为单元组织成 _组件_。这些 _组件_ 大致又组织成 _子系统_。跨越子系统的 _组件_ 可能被称为 _模块_。_模块_ 通常提供横切功能，例如持久存储或事件分发。理解这些 _组件_ 及其相互关系是修改和扩展系统的关键。

本文档将介绍非常高层次的交互。有关每个模块的详细信息，请参阅相关设计文档。

该架构的主要目标是协调 _bundle_ 的创建与执行。_Bundles_ 包含配置、元数据和根文件系统数据，并由 _runtime_ 消费。一个 _bundle_ 是运行时容器在磁盘上的表示。_Bundles_ 是可变的，可以传递给其他系统进行修改，或打包分发。实际上，它通常只是文件系统上的一个目录。

![架构](architecture.png)

注意：虽然这些架构思想对于理解系统很重要，但代码布局可能并不完全反映出相同的架构。应将这些思想作为放置功能与行为以及理解设计背后思路的指导。

## 子系统

外部用户通过 gRPC API 提供的服务与系统交互。

- **_Bundle_**：bundle 服务允许用户从磁盘镜像中提取和打包 bundles。
- **_Runtime_**：运行时服务支持对 _bundles_ 的执行，包括运行时容器的创建。

通常，每个子系统会有一个或多个相关的 _控制器_ 组件来实现该子系统的行为。子系统的行为可能通过相应的 _服务_ 导出以供访问。

## 模块

除了子系统之外，我们还有若干可能跨越子系统边界的组件（称为组件/模块）。主要包括：

- **_Executor_**：执行器实现实际的容器运行时。
- **_Supervisor_**：监督器监控并报告容器状态。
- **_Metadata_**：在图数据库中存储元数据。用于保存对镜像和 bundle 的任何持久引用。写入数据库的数据将由组件之间协调的 schema 管理，以便访问任意数据。其它功能还包括对磁盘资源进行垃圾回收的钩子。
- **_Content_**：提供对内容可寻址存储（content-addressable storage）的访问。所有不可变内容都存放在此处，并以内容哈希为键。
- **_Snapshot_**：管理容器镜像的文件系统快照。这类似于当前 Docker 中的 graphdriver。镜像层会被解包到快照中。
- **_Events_**：支持事件的收集与消费，以提供一致的事件驱动行为与审计。事件可以被重放到各个 _模块_。
- **_Metrics_**：每个组件都会导出若干指标，可通过指标 API 访问。（我们可能会将其提升为一个子系统。）

## 客户端侧组件

为提高灵活性，部分组件在客户端实现：

- **_Distribution_**：用于拉取与推送镜像的功能。

## 数据流

如上所述，_bundle_ 的概念是 containerd 的核心。下面的图示说明了 bundle 创建时的数据流。

![数据流](data-flow.png)

以拉取镜像为示例说明流程：

1. 指示分发层（Distribution）拉取特定镜像。分发层将镜像内容放入内容存储（content store）。镜像名称和根清单（root manifest）指针会在元数据存储中登记。
2. 镜像拉取完成后，用户可以指示 bundle 控制器将镜像解包为一个 bundle。控制器从内容存储读取数据，将镜像的各层解包到 snapshot 组件中。
3. 当容器根文件系统（rootfs）的快照准备就绪后，bundle 控制器可以使用镜像清单和配置来准备执行配置（execution configuration）。其中一部分工作是将来自 snapshot 模块的挂载项加入执行配置。
4. 准备好的 bundle 随后会交由运行时子系统（runtime）执行。运行时读取 bundle 的配置以创建正在运行的容器。
