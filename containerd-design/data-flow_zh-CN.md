# 数据流

过去，容器系统常常将拉取容器镜像的复杂性隐藏起来，许多细节与复杂流程对用户不可见。本文档旨在揭示这些复杂性，并从 containerd 用户的角度详细描述一次 “pull” 操作会是什么样子。我们在该工作流中以 _bundle_ 作为目标对象，并从该对象往回推来描述完整过程。在此上下文中，我们既会描述拉取镜像，也会描述如何从该镜像创建 bundle。

在 containerd 中，我们将 “pull” 重新定义为包含此前容器引擎所涵盖的同一组步骤。在这个模型中，镜像定义了一组可用于创建 _bundle_ 的资源。并不存在一种叫做 “image” 的特定格式或对象。pull 的目标是解析组成镜像的资源集合——这种分离在流程中提供了生命周期的切入点。

containerd 将提供一个在客户端执行的完整 “pull” 的参考实现，但这并不意味着会存在单一的 “pull” API 调用。

下面给出一个粗略的数据流图示以及相关组件。

![数据流](data-flow.png)

尽管流程在图中从左到右进行撰写，但本文档是从右向左来编写的。通过倒推该流程，我们可以最好地理解 containerd 所采用的方法。

## 运行一个容器

对于 containerd，我们通常希望检索一个 _bundle_。这是运行时在磁盘上的容器布局，包含运行容器所需的文件系统和配置。

一般来说，我们可以把它表示为下面的目录结构：

```
config.json
rootfs/
```

在此语境下，`config.json` 的具体内容并不重要，但为清晰起见，它可能是 runc 的配置或用于设置运行容器的 containerd 特定配置文件。`rootfs` 是 containerd 用来搭建运行时容器文件系统的目录。

尽管 containerd 没有镜像（image）的概念，我们仍然可以根据映射到 containerd 的镜像来构建上述结构。基于此，我们可以说运行一个容器所需的步骤为：

1. 将容器镜像中的配置转换为 containerd 运行时的目标格式。
2. 从容器镜像重建根文件系统（root filesystem）。我们可以把它解包到 bundle 的 `rootfs` 中，也可以将其作为一组挂载项传入容器配置。

以上定义了我们的工作框架。换句话说，我们希望通过创建 bundle 的这两个组成部分来创建一个 bundle。

## 创建一个 Bundle

既然我们已经定义了运行容器（即 _bundle_）所需的内容，就需要创建一个 bundle。

假设我们执行：

```
ctr run ubuntu
```

这并不会去拉取镜像。它仅仅使用名称创建一个 _bundle_。分解成步骤，该过程如下：

1. 在元数据存储（metadata store）中查找该镜像对应的 digest。
2. 在内容存储（content store）中解析 manifest。
3. 在 snapshot 子系统中解析层（layer）快照。
4. 将配置转换为目标 bundle 格式。
5. 为容器的 rootfs 创建运行时快照，包括对挂载点的解析。
6. 运行容器。

由此，我们可以理解拉取（_pull_）镜像所需的资源：

1. 在元数据存储中有一个条目，名称指向某个特定的 digest。
2. manifest 必须已存在于内容存储中。
3. 顺序应用各层后得到的结果必须以 snapshot 的形式可用。

## 解包（Unpacking）层

无论该过程是由 pull 驱动还是由 run 驱动，其思想都很简单。对于每一层，将该层的变更应用到前一层的 snapshot 上。结果应当根据 OCI 所定义的 chain id 来存储。

## 拉取（Pull）镜像

基于以上定义，拉取镜像变为以下步骤：

1. 获取镜像的 manifest，验证并存储它。
2. 获取镜像 manifest 中的每一层，验证并存储它们。
3. 将 manifest 的 digest 在所提供的名称下登记存储。

注意：此处我们暂不讨论如何使用名称解析到特定位置（registry 等）。那会另写一篇文档来说明。
